# VCS (Version Control System) - 버전 관리 시스템

코드나 문서 파일들의 변화를 기록하고 이를 과거로 되돌릴 수 있게 도와주는 시스템.

크게 3가지 종류가 있다.

- 로컬 VCS: 로컬에서만 사용
- 중앙집중식 VCS (CVCS): 중앙 서버에서 관리 (SVN 등)
- 분산형 VCS (DVCS): 각각의 개발자가 전체 히스토리를 로컬에 가짐

여기에서 흔히 사용되는 Git은 분산형 VCS에 속한다.

# Git

**Git**은 분산 버전 관리 시스템인데, `Linus Torvalds`라는 리눅스를 만든 사람이 만들었다.
기본적으로 로컬에서 작동하는 도구인데, .git 파일을 다른 사용자가 복사하면 해당 사용자도 원본과 동일한 파일 기록들을 얻을 수 있다.

# GitHub

GitHub는 Git을 클라우드에서 쓸 수 있게 만든 서비스 플랫폼이다.
인터넷 상에서 호스팅을 해주다보니, 여러 협업 과정에서 많이 사용된다. 특히 코딩 개발

# 깃 작동 방식

## 사전 지식

### Repository

스테이지에 있는 파일들을 버전으로 만들어서 저장하는 장소이다. 원격에 저장시킬 수도 있고, 로컬에 저장시킬 수도 있다.

로컬의 저장소의 경우에, 스테이지에 있는 파일 정보를 확인하기 위해서 `.git/index`(스테이지 내용)와 `.git/HEAD`(저장소 내용) 파일을 이용한다. commit을 하면 `.git/index` 내용을 .git/HEAD에 반영하게된다.

> 출처 : "https://inpa.tistory.com/entry/GIT-%E2%9A%A1%EF%B8%8F-%EA%B0%9C%EB%85%90-%EC%9B%90%EB%A6%AC-%EC%89%BD%EA%B2%8C%EC%9D%B4%ED%95%B4"

### git의 무결성

git에서 데이터를 저장할때에는 파일의 이름으로 저장하는 것이 아니라, `체크섬`이라는 문자열로 저장을 한다.
체크섬은 SHA-1 해시 알고리즘을 이용하여 만들어진다.

파일의 선후관계 또한 저장될 필요가 있는데, 이는 체크섬 문자열에 넣을 수가 없다. 따라서 Tree 구조 형식으로 저장하여
부모-자식과의 관계를 파일 내부에 저장시킨다.

# 깃 작동 과정 이해하기

`init -> add -> commit -> repository에 저장`의 과정을 차례대로 이해해보자.

## `init`

.git/ 디렉토리를 생성하는 명령어이다.
위 명령어를 사용하면 아래와 같은 디렉토리와 파일들이 생성된다.
| 항목 | 역할 |
| ------------- | --------------------------------------------------------------------------------------------- |
| `HEAD` | 현재 체크아웃된 브랜치를 가리킴. 보통 `ref: refs/heads/master`로 되어 있고, 브랜치가 머리를 어디에 두고 있는지 알려준다. |
| `config` | Git 저장소의 설정 파일. 사용자 이름, 푸시 주소, 브랜치 설정 등이 여기 저장됨. 전역 설정(`~/.gitconfig`)과 별도로 로컬 저장소에 적용됨. |
| `description` | 기본 설명. |
| `hooks/` | 커밋 전에 검사하거나, 푸시 후에 알림을 보내는 **트리거 스크립트**를 넣는 폴더. |
| `info/` | 무시할 파일 패턴 등을 넣는 곳. `.gitignore` 외에 추가 설정 가능하다. |
| `objects/` | Git이 실제 \*\*데이터(파일, 커밋, 트리)\*\*를 저장하는 곳. 핵심 중의 핵심. 나중에 `add`, `commit` 하면 여기에 blob/hash가 들어감. |
| `refs/` | 브랜치, 태그 등의 포인터 정보 저장. `refs/heads/master` 같은 파일에 커밋 해시를 저장해서 브랜치를 구성함. |

위와 같은 구조의 디렉토리들이 생성되는데 필수적으로 이해할 정보만 추리면 아래와 같다.

```text
.git/
├── objects/
│   ├── <blob>들 (파일 내용)
│   ├── <tree>들 (디렉토리 구조)
│   └── <commit> (스냅샷의 포인터)
├── refs/heads/<branch이름> → "<현재 포인팅하고있는 커밋 해시>"
└── HEAD → "refs/heads/master" (현재 보고있는 branch 이름)
```

### HEAD

```bash
$ cat .git/HEAD
ref: refs/heads/master
```

현재 헤드가 어느 브랜치를 가리키고 있는지를 저장시켜두는 파일이다.

# 명령어로 흐름 이해하기

## `add`

변경된 파일들을 Git이 추적할 수 있게 만드는 명령어로 주요 기능은 아래와 같다.

- Untracked 상태의 파일들을 Tracked 상태로 만든다
- modified 상태 파일들을 Staged 상태로 만든다.

### 내부 작동 방식 이해

```bash
$ git add hello.txt
```

위 명령어를 사용했을 때 어떤 과정을 거치게 되는지를 이해해보자.

1. `hello.txt` 파일의 내용을 읽는다.
2. 파일 내용을 압축해서 `blob`으로 저장한다.

- 파일 내용을 `SHA-1 해시`로 계산하여 ID를 생성한다.
- 이를 `blob`타입으로 `.git/objects/` 디렉토리에 저장한다.

3. `.git/index` 파일을 갱신한다. (스테이징 처리)

- blob 객체의 해시와 이 해시가 어떤 파일과 맵핑되는지를 `.git/index`에 저장한다.
- `.git/index` 에 저장된 객체상태 == 스테이징 상태

### **실제 데이터로 이해해보자.**

다음 내용의 hello.txt 파일이 있다.

```txt
hello world
```

이 데이터를 압축해서 blob 헤더를 만든다.

```
// "blob <size>\0<내용>" 의 형식으로 헤더를 만든다.
   blob 12\0hello world\n
```

이때 파일이름은 위에 들어가지 않는다.

작업한 위 blob을 바탕으로 SHA 해싱한다.

`e69de29bb2d1d6434b8b29ae775ad8c2e48c5391`

해싱 결과를 blob 객체의 ID로 사용한다.
(이때 파일 내용이 같은 blob 객체의 ID값이 동일한데, 이는 의도된 것이다. 동일한 내용의 파일을 효과적으로 저장하기 위함이다.)

그러고는 위 `blob데이터`를 zlib 압축한 이후에 `.git/objects/<ID 앞 2글자>/<ID>`로 저장한다. 위 blob 압축 파일은 `.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391`에 저장된다.

## `commit`

`.git/index`에 있는 파일을 기반으로 `스냅샷`을 만들어서 `commit 객체`로 변환시킨다.

### 내부 작동 방식 이해

1. 디렉토리를 하나의 tree Object로 변환한다.

- 해당 트리 객체 내부에는 디렉토리에 포함되어 있는 파일 정보를 `.git/index`에서 추출해서 저장시킨다.

2. commit object (위 트리를 가리키는 노드)를 생성한다.
3. tree, commit 객체를 `.git/objects/`에 저장한다.
4. HEAD가 가리키는 브랜치를 업데이트한다.

### **실제 데이터로 이해해보기**

**우선 트리 객체를 만들어야한다.**

디렉토리를 하나의 tree 객체로 만든다. 이때 루트 디렉토리도 만들어야한다.

```text
// 포맷 : <mode> <filename>\0 <SHA-1 해시값>

100644 app.js\0   b2c3d4...
100644 util.js\0  c3d4e5...
```

위 정보를 저장해서 tree 객체로 만들고, tree 객체 내용으로 SHA-1 계산을 하여 ID를 생성한다. -> `def123...`이후 생성한 트리 객체를 `.git/objects/de/f123...`에 저장한다.

다음 구조에서 `logger.js`와 `README.md` 파일을 수정하고 commit 했을 때 발생하는 과정을 알아보자.

```scss
commit C1(현재 커밋 포인트)
└─> tree T1 (root)
    ├── README.md → blob1
    └── src → tree T2
        ├── app.js → blob2
        └── util → tree T3
            └── logger.js → blob3
```

먼저 수정된 파일들을 `blob`으로 변환해야한다. 이는 add 과정인데 같이 설명하겠다.
`README.md`, `logger.js`를 각각 수정해서 blob4, blob5 객체를 만들어서 .git/objects/에 저장한다.

수정한 파일들이 속한 디렉토리부터 갱신한다. 차례대로 거슬러 올라가면서 객체를 갱신한다.

```scss
tree T3'
└── logger.js → blob5
```

먼저 logger.js -> blob3를 갱신한다. 그리고 이 정보를 담은 `tree Object`를 `T3`->`T3'`으로 갱신한다.

```scss
tree T2'
├── app.js → blob2 (변경 없음, 그대로)
└── util → T3'
```

T3가 바뀌었으므로 이를 반영하고 T2'으로 갱신한다.

```scss
tree T1'
├── README.md → blob4
└── src → T2'
```

README.md 파일과 T2를 갱신한다.

이를 모두 갱신한 다음 새로운 commit 객체를 생성한다.

```txt
tree <T1'>
parent <C1>
author me <you@example.com> <timestamp>
committer me <you@example.com> <timestamp>

Update README and logger (커밋 메시지)
```

tree 에는 갱신된 루트 디렉토리의 SHA-1 값을 적는다.
그리고 parent에는 이전 커밋 객체의 SHA-1 값을 적는다.

---

## `branch`

브랜치를 이해해보자. 위 내용을 이해하였다면 그리 어렵지 않게 이해할 수 있다.

```bash
$ git branch feature
```

feature 브랜치를 생성하였다. 그러면 새로운 브랜치 정보가 추가된다.

```
.git/
├── refs/
│   └── heads/
│       ├── master   → abc123...
│       └── feature  → abc123...   ← 새로 만든 브랜치
└── HEAD → refs/heads/master
```

위에서 `abc123...`은 브랜치를 생성할 시점의 커밋 객체의 SHA-1 값이다.

# Object 구조

## HEAD

`./git/HEAD`에 저장되어 있으며 어떤 브랜치의 어떤 부분을 가리키고 있는지를 담고있다.

```bash
$ cat .git/refs/heads/master
a7d3c1b4e2...
```

해당 브랜치의 커밋객체 해시값이 저장되어있다.

## commit Object

커밋 객체의 구조는 다음과 같다.

```
tree <트리의 해시>
parent <이전 커밋의 해시>
author 이름 이메일 timestamp
comitter 이름 이메일 timestamp

커밋 메시지 내용
```

실제 내용을 보면 아래와 같다.

```text
tree 94c9a4c512...
(첫 커밋이라 부모 노드가 없다)
author You <you@example.com> 1722240000 +0900
committer You <you@example.com> 1722240000 +0900

Initial commit
```

## 트리 구조로 디렉토리 정보까지 저장하기

```scss
(root tree)
├── README.md → blob(f5e4d3...)
└── src → tree(2e7a9f...)
       └── app.js → blob(a1b2c3...)
```

## 파일 모드

| 파일 모드 (8진수) | 10진수 | 의미                 | 설명                              |
| ----------------- | ------ | -------------------- | --------------------------------- |
| `100644`          | 33188  | 일반 파일            | 읽기/쓰기 가능, 실행 불가         |
| `100755`          | 33261  | 실행 파일            | 읽기/쓰기/실행 가능               |
| `120000`          | 40960  | 심볼릭 링크          | 심볼릭 링크 대상의 경로 저장      |
| `040000`          | 16384  | 디렉토리 (tree 객체) | tree 객체로 표현되는 서브디렉토리 |

---

# `git clone에 대해`

```bash
$ git clone <원격저장소URL> [디렉토리명]
```

일반적으로 clone을 하기 위한 방법은 `HTTPS`링크를 이용한 방법과 `SSH`를 이용한 방법이 있다.

해당 HTTPS 링크에 GET 요청을 보내면 자동으로 .git 관련 파일이 다운로드 되는 것은 아니다.
구현이 상당히 복잡한데 결과부터 말하자면 Git에서 보낸 요청만 허용한다.
절차는 아래와 같다.

1. 원격 저장소에 연결 (URL이 https://, git@, ssh://인지 파악)
2. 참조(refs) 정보 요청 및 다운로드
   GET /info/refs?service=git-upload-pack을 요청하고 packfile 파일을 받는다. 해당 파일은 일종의 .git 압축파일이라고 생각하면 된다.
3. .git 디렉토리 생성
4. 워킹 디렉토리 초기화
   HEAD 기준 브랜치의 최신 커밋을 체크아웃한다.
